name: 'GitHub Release'
description: 'Create a GitHub release with optional package manager setup for building/testing'

inputs:
  github-token:
    description: |
      GitHub token for creating releases. Typically use the built-in GITHUB_TOKEN or a personal access token.
      Example: secrets.GITHUB_TOKEN
    required: true
  release-branch:
    description: |
      Branch to create release from. The branch that contains the code to be released.
      Examples: 'main', 'develop', 'release/v2.0', 'production'
    required: false
    default: 'main'
  increment:
    description: |
      Version increment type used by commitizen for semantic versioning.
      - patch: Bug fixes (1.0.0 -> 1.0.1)
      - minor: New features (1.0.1 -> 1.1.0)
      - major: Breaking changes (1.1.0 -> 2.0.0)
    required: false
    type: choice
    options:
      - patch
      - minor
      - major
    default: 'patch'
  prerelease-type:
    description: |
      Prerelease type appended to the version (used with commitizen --prerelease flag).
      - none: Standard release (1.0.0)
      - alpha: Alpha release (1.0.0-alpha.1)
      - beta: Beta release (1.0.0-beta.1)
      - rc: Release candidate (1.0.0-rc.1)
    required: false
    type: choice
    options:
      - none
      - alpha
      - beta
      - rc
    default: 'none'
  draft:
    description: |
      Create as draft release (passed to softprops/action-gh-release).
      - 'true': Release will be created as draft (not published)
      - 'false': Release will be published immediately
    required: false
    default: 'false'
  package-manager:
    description: |
      Package manager to use for setting up Python environment before release.
      Determines which python-setup action to use.
      - pip: Standard pip with pyproject.toml
      - uv: UV package manager (faster, modern)
      - pixi: Pixi package manager (conda-based)
    required: false
    type: choice
    options:
      - pip
      - uv
      - pixi
    default: 'uv'
  python-version:
    description: |
      Python version to install (passed to actions/setup-python).
      Supports semantic versioning and version ranges.
      Examples: '3.12', '3.11', '3.10', '3.9', '3.12.0', '3.x'
    required: false
    default: '3.12'
  install-groups:
    description: |
      Dependency groups or environments to install.
      Format varies by package-manager:

      For pip/uv (passed to install-groups):
        - "groups: dev test" - Install dependency groups (PEP 735)
        - "extras: aws viz" - Install optional dependencies (extras)
        - "groups: dev docs, extras: aws" - Combine both
        - "" - Install only core dependencies

      For pixi (passed to environments and activate-environment):
        - "default" - Use default environment
        - "py311" - Single named environment
        - "py312 py313" - Multiple environments (space-separated)

      Note: When using pixi, specify only one environment name as it's used for both
      environments and activate-environment parameters.
    required: false
    default: 'groups: docs dev'
  skip-checkout:
    description: |
      Skip the checkout step. FOR TESTING ONLY - do not use in production!

      In production, the checkout step is essential because it:
      - Ensures you're on the correct release-branch
      - Fetches full git history needed by commitizen
      - Guarantees a clean state before version bumping

      Only set to 'true' when testing the action with pre-staged fixtures.

      - 'false': Checkout repository (default, use this in production)
      - 'true': Skip checkout (testing only)
    required: false
    default: 'false'

runs:
  using: 'composite'
  steps:
    - name: Checkout repository
      if: ${{ inputs.skip-checkout != 'true' }}
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
        ref: ${{ inputs.release-branch }}

    - name: Check prerequisites for release
      shell: bash
      run: |
        echo "::group::Checking release prerequisites"
        echo "=== Validating release requirements ==="

        # Check if there are any existing tags
        echo ""
        echo "Checking for existing tags..."
        EXISTING_TAGS=$(git tag -l)
        if [ -z "$EXISTING_TAGS" ]; then
          echo "::warning::No existing tags found in repository"
          echo "::warning::This appears to be the first release"
          echo "::warning::Full changelog will be generated instead of incremental"
        else
          echo "✓ Found existing tags:"
          echo "$EXISTING_TAGS" | head -5
          if [ $(echo "$EXISTING_TAGS" | wc -l) -gt 5 ]; then
            echo "  ... and $(($(echo "$EXISTING_TAGS" | wc -l) - 5)) more"
          fi
        fi

        # Check if CHANGELOG.md exists
        echo ""
        echo "Checking for CHANGELOG.md file..."
        if [ ! -f "CHANGELOG.md" ]; then
          echo "::error::CHANGELOG.md file not found"
          echo "::error::A CHANGELOG.md file is required for release generation"
          echo "::error::Please create CHANGELOG.md in the repository root before creating a release"
          echo "::error::You can create an empty file or run 'cz changelog' to generate one"
          exit 1
        else
          echo "✓ CHANGELOG.md file exists"
        fi

        echo ""
        echo "✓ All prerequisites validated successfully"
        echo "========================================"
        echo "::endgroup::"

    - name: Display release configuration
      shell: bash
      run: |
        echo "::group::Release Configuration"
        echo "=== GitHub Release Action Configuration ==="
        if [ "${{ inputs.skip-checkout }}" = "true" ]; then
          echo "✗ Repository checkout: Skipped (skip-checkout=true)"
        else
          echo "✓ Repository checkout: Enabled"
          echo "  Branch: ${{ inputs.release-branch }}"
        fi
        echo "✓ Package manager: ${{ inputs.package-manager }}"
        echo "✓ Python version: ${{ inputs.python-version }}"
        echo "✓ Version increment: ${{ inputs.increment }}"
        if [ "${{ inputs.prerelease-type }}" != "none" ]; then
          echo "✓ Prerelease type: ${{ inputs.prerelease-type }}"
        else
          echo "✗ Prerelease type: none (standard release)"
        fi
        if [ "${{ inputs.draft }}" = "true" ]; then
          echo "✓ Draft release: Yes"
        else
          echo "✗ Draft release: No (will be published)"
        fi
        if [ -n "${{ inputs.install-groups }}" ]; then
          echo "✓ Install groups: ${{ inputs.install-groups }}"
        else
          echo "✗ Install groups: none (core dependencies only)"
        fi
        echo "========================================"
        echo "::endgroup::"


    - name: Set up Python environment (pip)
      if: ${{ inputs.package-manager == 'pip' }}
      uses: Serapieum-of-alex/github-actions/actions/python-setup/pip@pip/v1
      with:
        python-version: ${{ inputs.python-version }}
        install-groups: ${{ inputs.install-groups }}

    - name: Set up Python environment (uv)
      if: ${{ inputs.package-manager == 'uv' }}
      uses: Serapieum-of-alex/github-actions/actions/python-setup/uv@uv/v1
      with:
        python-version: ${{ inputs.python-version }}
        install-groups: ${{ inputs.install-groups }}

    - name: Set up Python environment (pixi)
      if: ${{ inputs.package-manager == 'pixi' }}
      uses: Serapieum-of-alex/github-actions/actions/python-setup/pixi@pixi/v1
      with:
        environments: ${{ inputs.install-groups }}
        activate-environment: ${{ inputs.install-groups }}

    - name: Configure Git
      shell: bash
      run: |
        echo "::group::Configuring Git for version bump"
        echo "Setting git user configuration..."
        git config --global user.name '${{ github.actor }}'
        git config --global user.email '${{ github.actor }}@users.noreply.github.com'
        echo "✓ Git configured with user: ${{ github.actor }}"
        echo "::endgroup::"

    - name: Generate changelog and bump version with commitizen
      id: bump_version
      shell: bash
      run: |
        echo "::group::Preparing commitizen command"

        # Build commitizen command based on package manager
        if [ "${{ inputs.package-manager }}" = "pip" ]; then
          CZ_CMD="cz"
          echo "Using pip package manager"
          echo "✓ Commitizen command: cz"
        elif [ "${{ inputs.package-manager }}" = "pixi" ]; then
          CZ_CMD="pixi run -e ${{ inputs.install-groups }} cz"
          echo "Using pixi package manager"
          echo "✓ Commitizen command: pixi run -e ${{ inputs.install-groups }} cz"
        else
          CZ_CMD="${{ inputs.package-manager }} run cz"
          echo "Using ${{ inputs.package-manager }} package manager"
          echo "✓ Commitizen command: ${{ inputs.package-manager }} run cz"
        fi
        echo "::endgroup::"

        echo "::group::Getting current version"
        CURRENT_VERSION=$($CZ_CMD version --project)
        echo "✓ Current version: $CURRENT_VERSION"
        echo "::endgroup::"

        echo "::group::Calculating next version"
        echo "Increment type: ${{ inputs.increment }}"
        if [ "${{ inputs.prerelease-type }}" != "none" ]; then
          echo "Prerelease type: ${{ inputs.prerelease-type }}"
          echo "Running dry-run to calculate version..."
          NEXT_VERSION=$($CZ_CMD bump --dry-run --increment ${{ inputs.increment }} --prerelease ${{ inputs.prerelease-type }} | grep "tag to create" | awk '{print $NF}')
        else
          echo "Prerelease type: none (standard release)"
          echo "Running dry-run to calculate version..."
          NEXT_VERSION=$($CZ_CMD bump --dry-run --increment ${{ inputs.increment }} | grep "tag to create" | awk '{print $NF}')
        fi
        echo "✓ Next version will be: $NEXT_VERSION"
        echo "  Version change: $CURRENT_VERSION → $NEXT_VERSION"
        echo "::endgroup::"

        echo "::group::Bumping version and generating changelog"
        echo "Running cz bump (handles both version and changelog)..."

        # Run cz bump - it handles changelog generation automatically
        # If it fails, we'll recover by generating full changelog and retrying
        set +e  # Don't exit on error
        if [ "${{ inputs.prerelease-type }}" != "none" ]; then
          $CZ_CMD bump --yes --increment ${{ inputs.increment }} --prerelease ${{ inputs.prerelease-type }}
          BUMP_EXIT_CODE=$?
        else
          $CZ_CMD bump --yes --increment ${{ inputs.increment }}
          BUMP_EXIT_CODE=$?
        fi
        set -e  # Re-enable exit on error

        # If bump failed, recover by generating full changelog and retrying with --files-only
        if [ $BUMP_EXIT_CODE -ne 0 ]; then
          echo "⚠ cz bump encountered an issue (exit code: $BUMP_EXIT_CODE)"
          echo "Recovering: generating full changelog and retrying..."

          # Generate full changelog
          $CZ_CMD changelog --unreleased-version="$NEXT_VERSION"

          # Retry bump with --files-only (skip changelog since we just generated it)
          if [ "${{ inputs.prerelease-type }}" != "none" ]; then
            $CZ_CMD bump --yes --increment ${{ inputs.increment }} --prerelease ${{ inputs.prerelease-type }} --files-only
          else
            $CZ_CMD bump --yes --increment ${{ inputs.increment }} --files-only
          fi
          echo "✓ Recovery successful"
        fi

        echo "✓ Version bump and changelog generation completed"
        echo "::endgroup::"

        echo "::group::Verifying version bump"
        NEW_VERSION=$($CZ_CMD version --project)
        echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT

        if [ "$NEW_VERSION" = "$NEXT_VERSION" ]; then
          echo "✓ Version bump verified successfully"
          echo "  Final version: $NEW_VERSION"
        else
          echo "::warning::Version mismatch detected!"
          echo "  Expected: $NEXT_VERSION"
          echo "  Actual: $NEW_VERSION"
        fi

        echo ""
        echo "=== Version Bump Summary ==="
        echo "Previous version: $CURRENT_VERSION"
        echo "New version: $NEW_VERSION"
        echo "Increment type: ${{ inputs.increment }}"
        if [ "${{ inputs.prerelease-type }}" != "none" ]; then
          echo "Prerelease: ${{ inputs.prerelease-type }}"
        fi
        echo "=========================="
        echo "::endgroup::"

    - name: Push changes and tags
      shell: bash
      run: |
        echo "::group::Pushing changes and tags to repository"

        echo "Pushing version bump commit to ${{ inputs.release-branch }}..."
        if ! git push; then
          echo "::error::Failed to push changes to repository"
          echo "::error::Branch: ${{ inputs.release-branch }}"
          exit 1
        fi
        echo "✓ Changes pushed successfully"

        echo ""
        echo "Pushing tags to repository..."
        if ! git push --tags; then
          echo "::error::Failed to push tags to repository"
          exit 1
        fi
        echo "✓ Tags pushed successfully"

        echo ""
        echo "=== Git Push Summary ==="
        echo "✓ Version bump committed and pushed"
        echo "✓ Git tag created and pushed"
        echo "  Tag: ${{ steps.bump_version.outputs.NEW_VERSION }}"
        echo "  Branch: ${{ inputs.release-branch }}"
        echo "======================="
        echo "::endgroup::"

    - name: Create GitHub Release
      shell: bash
      run: |
        echo "::group::Creating GitHub Release"
        echo "Release details:"
        echo "  Version: ${{ steps.bump_version.outputs.NEW_VERSION }}"
        echo "  Tag: ${{ steps.bump_version.outputs.NEW_VERSION }}"
        if [ "${{ inputs.draft }}" = "true" ]; then
          echo "  Type: Draft release"
        else
          echo "  Type: Published release"
        fi

        # Check if this is a prerelease
        VERSION="${{ steps.bump_version.outputs.NEW_VERSION }}"
        if [[ "$VERSION" == *"-"* ]] || [[ "$VERSION" == *"alpha"* ]] || [[ "$VERSION" == *"beta"* ]] || [[ "$VERSION" == *"rc"* ]]; then
          echo "  Prerelease: Yes"
        else
          echo "  Prerelease: No"
        fi
        echo "::endgroup::"

    - name: Publish GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        token: ${{ inputs.github-token }}
        name: ${{ steps.bump_version.outputs.NEW_VERSION }}
        tag_name: ${{ steps.bump_version.outputs.NEW_VERSION }}
        draft: ${{ inputs.draft == 'true' }}
        prerelease: ${{ contains(steps.bump_version.outputs.NEW_VERSION, '-') || contains(steps.bump_version.outputs.NEW_VERSION, 'alpha') || contains(steps.bump_version.outputs.NEW_VERSION, 'beta') || contains(steps.bump_version.outputs.NEW_VERSION, 'rc') }}
        generate_release_notes: true

    - name: Release summary
      shell: bash
      run: |
        echo "::group::Release Summary"
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "        GitHub Release Created"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo ""
        echo "✓ Version: ${{ steps.bump_version.outputs.NEW_VERSION }}"
        echo "✓ Branch: ${{ inputs.release-branch }}"
        echo "✓ Increment: ${{ inputs.increment }}"
        if [ "${{ inputs.prerelease-type }}" != "none" ]; then
          echo "✓ Prerelease: ${{ inputs.prerelease-type }}"
        fi
        if [ "${{ inputs.draft }}" = "true" ]; then
          echo "✓ Status: Draft (not published)"
        else
          echo "✓ Status: Published"
        fi
        echo ""
        echo "View release: ${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ steps.bump_version.outputs.NEW_VERSION }}"
        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "::endgroup::"